name: CI Dev

on:
  push:
    branches: [ main ]
  workflow_dispatch:

# 讓 GITHUB_TOKEN 可以寫入 release/contents
permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 不依賴任何語言環境，純粹做出一個可用的 build.zip
      - name: Create build artifact
        run: |
          mkdir -p dist
          echo "Build from $GITHUB_SHA at $(date -u)" > dist/info.txt
          zip -r build.zip dist

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: build.zip

  deploy-dev:
    needs: build
    runs-on: ubuntu-latest
    environment: dev
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: build-artifact

      # 用 GH CLI 發佈 release：
      # 1) 改用 GH_TOKEN（gh 預設辨識的變數名）
      # 2) 避免 tag 碰撞：在 BUILD_TAG 後面加上 run number
      # 3) 若同一 tag 已存在就改成 upload --clobber
      - name: Release Dev build
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}     # gh 會吃 GH_TOKEN 或 GITHUB_TOKEN；這裡明確給 GH_TOKEN
          TAG_BASE: ${{ vars.BUILD_TAG }}          # 例如 dev-v1.0（在 Environment: dev 設定）
          NOTE: ${{ vars.RELEASE_NOTE }}           # 例如 Development build release
        run: |
          TAG="${TAG_BASE}-${GITHUB_RUN_NUMBER}"

          echo "TAG to use: $TAG"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists -> upload artifact (clobber)"
            gh release upload "$TAG" build.zip --clobber
          else
            echo "Create new release $TAG"
            gh release create "$TAG" build.zip --title "$TAG" --notes "$NOTE"
          fi
